.TH "QwtSymbol" 3 "Sat Jan 26 2013" "Version 6.1-rc3" "Qwt User's Guide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QwtSymbol \- 
.PP
A class for drawing symbols\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <qwt_symbol\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBStyle\fP { \fBNoSymbol\fP = -1, \fBEllipse\fP, \fBRect\fP, \fBDiamond\fP, \fBTriangle\fP, \fBDTriangle\fP, \fBUTriangle\fP, \fBLTriangle\fP, \fBRTriangle\fP, \fBCross\fP, \fBXCross\fP, \fBHLine\fP, \fBVLine\fP, \fBStar1\fP, \fBStar2\fP, \fBHexagon\fP, \fBPath\fP, \fBPixmap\fP, \fBGraphic\fP, \fBSvgDocument\fP, \fBUserStyle\fP = 1000 }"
.br
.ti -1c
.RI "enum \fBCachePolicy\fP { \fBNoCache\fP, \fBCache\fP, \fBAutoCache\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQwtSymbol\fP (\fBStyle\fP=\fBNoSymbol\fP)"
.br
.ti -1c
.RI "\fBQwtSymbol\fP (\fBStyle\fP, const QBrush &, const QPen &, const QSize &)"
.br
.RI "\fIConstructor\&. \fP"
.ti -1c
.RI "\fBQwtSymbol\fP (const QPainterPath &, const QBrush &, const QPen &)"
.br
.RI "\fIConstructor\&. \fP"
.ti -1c
.RI "virtual \fB~QwtSymbol\fP ()"
.br
.RI "\fIDestructor\&. \fP"
.ti -1c
.RI "void \fBsetCachePolicy\fP (\fBCachePolicy\fP)"
.br
.ti -1c
.RI "\fBCachePolicy\fP \fBcachePolicy\fP () const "
.br
.ti -1c
.RI "void \fBsetSize\fP (const QSize &)"
.br
.ti -1c
.RI "void \fBsetSize\fP (int width, int height=-1)"
.br
.RI "\fISpecify the symbol's size\&. \fP"
.ti -1c
.RI "const QSize & \fBsize\fP () const "
.br
.ti -1c
.RI "void \fBsetPinPoint\fP (const QPointF &pos, bool enable=true)"
.br
.RI "\fISet and enable a pin point\&. \fP"
.ti -1c
.RI "QPointF \fBpinPoint\fP () const "
.br
.ti -1c
.RI "void \fBsetPinPointEnabled\fP (bool)"
.br
.ti -1c
.RI "bool \fBisPinPointEnabled\fP () const "
.br
.ti -1c
.RI "virtual void \fBsetColor\fP (const QColor &)"
.br
.RI "\fISet the color of the symbol\&. \fP"
.ti -1c
.RI "void \fBsetBrush\fP (const QBrush &b)"
.br
.RI "\fIAssign a brush\&. \fP"
.ti -1c
.RI "const QBrush & \fBbrush\fP () const "
.br
.ti -1c
.RI "void \fBsetPen\fP (const QColor &, qreal width=0\&.0, Qt::PenStyle=Qt::SolidLine)"
.br
.ti -1c
.RI "void \fBsetPen\fP (const QPen &)"
.br
.ti -1c
.RI "const QPen & \fBpen\fP () const "
.br
.ti -1c
.RI "void \fBsetStyle\fP (\fBStyle\fP)"
.br
.ti -1c
.RI "\fBStyle\fP \fBstyle\fP () const "
.br
.ti -1c
.RI "void \fBsetPath\fP (const QPainterPath &)"
.br
.RI "\fISet a painter path as symbol\&. \fP"
.ti -1c
.RI "const QPainterPath & \fBpath\fP () const "
.br
.ti -1c
.RI "void \fBsetPixmap\fP (const QPixmap &)"
.br
.ti -1c
.RI "const QPixmap & \fBpixmap\fP () const "
.br
.ti -1c
.RI "void \fBsetGraphic\fP (const \fBQwtGraphic\fP &)"
.br
.ti -1c
.RI "const \fBQwtGraphic\fP & \fBgraphic\fP () const "
.br
.ti -1c
.RI "void \fBsetSvgDocument\fP (const QByteArray &)"
.br
.ti -1c
.RI "void \fBdrawSymbol\fP (QPainter *, const QRectF &) const "
.br
.RI "\fIDraw the symbol into a rectangle\&. \fP"
.ti -1c
.RI "void \fBdrawSymbol\fP (QPainter *, const QPointF &) const "
.br
.RI "\fIDraw the symbol at a specified position\&. \fP"
.ti -1c
.RI "void \fBdrawSymbols\fP (QPainter *, const QPolygonF &) const "
.br
.RI "\fIDraw symbols at the specified points\&. \fP"
.ti -1c
.RI "void \fBdrawSymbols\fP (QPainter *, const QPointF *, int numPoints) const "
.br
.ti -1c
.RI "virtual QRect \fBboundingRect\fP () const "
.br
.ti -1c
.RI "void \fBinvalidateCache\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBrenderSymbols\fP (QPainter *, const QPointF *, int numPoints) const "
.br
.in -1c
.SH "Detailed Description"
.PP 
A class for drawing symbols\&. 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBQwtSymbol::CachePolicy\fP"
Depending on the render engine and the complexity of the symbol shape it might be faster to render the symbol to a pixmap and to paint this pixmap\&.
.PP
F\&.e\&. the raster paint engine is a pure software renderer where in cache mode a draw operation usually ends in raster operation with the the backing store, that are usually faster, than the algorithms for rendering polygons\&. But the opposite can be expected for graphic pipelines that can make use of hardware acceleration\&.
.PP
The default setting is AutoCache
.PP
\fBSee Also:\fP
.RS 4
\fBsetCachePolicy()\fP, \fBcachePolicy()\fP
.RE
.PP
\fBNote:\fP
.RS 4
The policy has no effect, when the symbol is painted to a vector graphics format ( PDF, SVG )\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Since Qt 4\&.8 raster is the default backend on X11 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINoCache \fP\fP
Don't use a pixmap cache\&. 
.TP
\fB\fICache \fP\fP
Always use a pixmap cache\&. 
.TP
\fB\fIAutoCache \fP\fP
Use a cache when one of the following conditions is true:
.PP
.IP "\(bu" 2
The symbol is rendered with the software renderer ( QPaintEngine::Raster ) 
.PP

.SS "enum \fBQwtSymbol::Style\fP"
Symbol Style 
.PP
\fBSee Also:\fP
.RS 4
\fBsetStyle()\fP, \fBstyle()\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINoSymbol \fP\fP
No Style\&. The symbol cannot be drawn\&. 
.TP
\fB\fIEllipse \fP\fP
Ellipse or circle\&. 
.TP
\fB\fIRect \fP\fP
Rectangle\&. 
.TP
\fB\fIDiamond \fP\fP
Diamond\&. 
.TP
\fB\fITriangle \fP\fP
Triangle pointing upwards\&. 
.TP
\fB\fIDTriangle \fP\fP
Triangle pointing downwards\&. 
.TP
\fB\fIUTriangle \fP\fP
Triangle pointing upwards\&. 
.TP
\fB\fILTriangle \fP\fP
Triangle pointing left\&. 
.TP
\fB\fIRTriangle \fP\fP
Triangle pointing right\&. 
.TP
\fB\fICross \fP\fP
Cross (+) 
.TP
\fB\fIXCross \fP\fP
Diagonal cross (X) 
.TP
\fB\fIHLine \fP\fP
Horizontal line\&. 
.TP
\fB\fIVLine \fP\fP
Vertical line\&. 
.TP
\fB\fIStar1 \fP\fP
X combined with +\&. 
.TP
\fB\fIStar2 \fP\fP
Six-pointed star\&. 
.TP
\fB\fIHexagon \fP\fP
Hexagon\&. 
.TP
\fB\fIPath \fP\fP
The symbol is represented by a painter path, where the origin ( 0, 0 ) of the path coordinate system is mapped to the position of the symbol\&.
.PP
\fBSee Also:\fP
.RS 4
\fBsetPath()\fP, \fBpath()\fP 
.RE
.PP

.TP
\fB\fIPixmap \fP\fP
The symbol is represented by a pixmap\&. The pixmap is centered or aligned to its pin point\&.
.PP
\fBSee Also:\fP
.RS 4
\fBsetPinPoint()\fP 
.RE
.PP

.TP
\fB\fIGraphic \fP\fP
The symbol is represented by a graphic\&. The graphic is centered or aligned to its pin point\&.
.PP
\fBSee Also:\fP
.RS 4
\fBsetPinPoint()\fP 
.RE
.PP

.TP
\fB\fISvgDocument \fP\fP
The symbol is represented by a SVG graphic\&. The graphic is centered or aligned to its pin point\&.
.PP
\fBSee Also:\fP
.RS 4
\fBsetPinPoint()\fP 
.RE
.PP

.TP
\fB\fIUserStyle \fP\fP
Styles >= QwtSymbol::UserSymbol are reserved for derived classes of \fBQwtSymbol\fP that overload \fBdrawSymbols()\fP with additional application specific symbol types\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "QwtSymbol::QwtSymbol (\fBStyle\fPstyle = \fC\fBNoSymbol\fP\fP)"
Default Constructor 
.PP
\fBParameters:\fP
.RS 4
\fIstyle\fP Symbol Style
.RE
.PP
The symbol is constructed with gray interior, black outline with zero width, no size and style 'NoSymbol'\&. 
.SS "QwtSymbol::QwtSymbol (\fBQwtSymbol::Style\fPstyle, const QBrush &brush, const QPen &pen, const QSize &size)"

.PP
Constructor\&. \fBParameters:\fP
.RS 4
\fIstyle\fP Symbol Style 
.br
\fIbrush\fP brush to fill the interior 
.br
\fIpen\fP outline pen 
.br
\fIsize\fP size
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetStyle()\fP, \fBsetBrush()\fP, \fBsetPen()\fP, \fBsetSize()\fP 
.RE
.PP

.SS "QwtSymbol::QwtSymbol (const QPainterPath &path, const QBrush &brush, const QPen &pen)"

.PP
Constructor\&. The symbol gets initialized by a painter path\&. The style is set to \fBQwtSymbol::Path\fP, the size is set to empty ( the path is displayed unscaled )\&.
.PP
\fBParameters:\fP
.RS 4
\fIpath\fP painter path 
.br
\fIbrush\fP brush to fill the interior 
.br
\fIpen\fP outline pen
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetPath()\fP, \fBsetBrush()\fP, \fBsetPen()\fP, \fBsetSize()\fP 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "QRect QwtSymbol::boundingRect () const\fC [virtual]\fP"
Calculate the bounding rectangle for a symbol at position (0,0)\&.
.PP
\fBReturns:\fP
.RS 4
Bounding rectangle 
.RE
.PP

.SS "const QBrush & QwtSymbol::brush () const"
\fBReturns:\fP
.RS 4
Brush 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetBrush()\fP 
.RE
.PP

.SS "\fBQwtSymbol::CachePolicy\fP QwtSymbol::cachePolicy () const"
\fBReturns:\fP
.RS 4
Cache policy 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBCachePolicy\fP, \fBsetCachePolicy()\fP 
.RE
.PP

.SS "void QwtSymbol::drawSymbol (QPainter *painter, const QRectF &rect) const"

.PP
Draw the symbol into a rectangle\&. The symbol is painted centered and scaled into the target rectangle\&. It is always painted uncached and the pin point is ignored\&.
.PP
This method is primarily intended for drawing a symbol to the legend\&.
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIrect\fP Target rectangle for the symbol 
.RE
.PP

.SS "void QwtSymbol::drawSymbol (QPainter *painter, const QPointF &pos) const\fC [inline]\fP"

.PP
Draw the symbol at a specified position\&. \fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIpos\fP Position of the symbol in screen coordinates 
.RE
.PP

.SS "void QwtSymbol::drawSymbols (QPainter *painter, const QPolygonF &points) const\fC [inline]\fP"

.PP
Draw symbols at the specified points\&. \fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIpoints\fP Positions of the symbols in screen coordinates 
.RE
.PP

.SS "void QwtSymbol::drawSymbols (QPainter *painter, const QPointF *points, intnumPoints) const"
Render an array of symbols
.PP
Painting several symbols is more effective than drawing symbols one by one, as a couple of layout calculations and setting of pen/brush can be done once for the complete array\&.
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIpoints\fP Array of points 
.br
\fInumPoints\fP Number of points 
.RE
.PP

.SS "const \fBQwtGraphic\fP & QwtSymbol::graphic () const"
\fBReturns:\fP
.RS 4
Assigned graphic 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetGraphic()\fP 
.RE
.PP

.SS "void QwtSymbol::invalidateCache ()"
Invalidate the cached symbol pixmap
.PP
The symbol invalidates its cache, whenever an attribute is changed that has an effect ob how to display a symbol\&. In case of derived classes with individual styles ( >= \fBQwtSymbol::UserStyle\fP ) it might be necessary to call \fBinvalidateCache()\fP for attributes that are relevant for this style\&.
.PP
\fBSee Also:\fP
.RS 4
\fBCachePolicy\fP, \fBsetCachePolicy()\fP, \fBdrawSymbols()\fP 
.RE
.PP

.SS "bool QwtSymbol::isPinPointEnabled () const"
\fBReturns:\fP
.RS 4
True, when the pin point translation is enabled 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetPinPoint()\fP, \fBsetPinPointEnabled()\fP 
.RE
.PP

.SS "const QPainterPath & QwtSymbol::path () const"
\fBReturns:\fP
.RS 4
Painter path for displaying the symbol 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetPath()\fP 
.RE
.PP

.SS "const QPen & QwtSymbol::pen () const"
\fBReturns:\fP
.RS 4
Pen 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetPen()\fP, \fBbrush()\fP 
.RE
.PP

.SS "QPointF QwtSymbol::pinPoint () const"
\fBReturns:\fP
.RS 4
Pin point 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetPinPoint()\fP, \fBsetPinPointEnabled()\fP 
.RE
.PP

.SS "const QPixmap & QwtSymbol::pixmap () const"
\fBReturns:\fP
.RS 4
Assigned pixmap 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetPixmap()\fP 
.RE
.PP

.SS "void QwtSymbol::renderSymbols (QPainter *painter, const QPointF *points, intnumPoints) const\fC [protected]\fP, \fC [virtual]\fP"
Render the symbol to series of points
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Qt painter 
.br
\fIpoints\fP Positions of the symbols 
.br
\fInumPoints\fP Number of points 
.RE
.PP

.SS "void QwtSymbol::setBrush (const QBrush &brush)"

.PP
Assign a brush\&. The brush is used to draw the interior of the symbol\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbrush\fP Brush
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBbrush()\fP 
.RE
.PP

.SS "void QwtSymbol::setCachePolicy (\fBQwtSymbol::CachePolicy\fPpolicy)"
Change the cache policy
.PP
The default policy is AutoCache
.PP
\fBParameters:\fP
.RS 4
\fIpolicy\fP Cache policy 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBCachePolicy\fP, \fBcachePolicy()\fP 
.RE
.PP

.SS "void QwtSymbol::setColor (const QColor &color)\fC [virtual]\fP"

.PP
Set the color of the symbol\&. Change the color of the brush for symbol types with a filled area\&. For all other symbol types the color will be assigned to the pen\&.
.PP
\fBParameters:\fP
.RS 4
\fIcolor\fP Color
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetBrush()\fP, \fBsetPen()\fP, \fBbrush()\fP, \fBpen()\fP 
.RE
.PP

.SS "void QwtSymbol::setGraphic (const \fBQwtGraphic\fP &graphic)"
Set a graphic as symbol
.PP
\fBParameters:\fP
.RS 4
\fIgraphic\fP Graphic
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBgraphic()\fP, \fBsetPixmap()\fP
.RE
.PP
\fBNote:\fP
.RS 4
the \fBstyle()\fP is set to \fBQwtSymbol::Graphic\fP 
.PP
\fBbrush()\fP and \fBpen()\fP have no effect 
.RE
.PP

.SS "void QwtSymbol::setPath (const QPainterPath &path)"

.PP
Set a painter path as symbol\&. The symbol is represented by a painter path, where the origin ( 0, 0 ) of the path coordinate system is mapped to the position of the symbol\&.
.PP
When the symbol has valid size the painter path gets scaled to fit into the size\&. Otherwise the symbol size depends on the bounding rectangle of the path\&.
.PP
The following code defines a symbol drawing an arrow:
.PP
.PP
.nf
#include <qwt_symbol.h>

QwtSymbol *symbol = new QwtSymbol();

QPen pen( Qt::black, 2 );
pen.setJoinStyle( Qt::MiterJoin );

symbol->setPen( pen );
symbol->setBrush( Qt::red );

QPainterPath path;
path.moveTo( 0, 8 );
path.lineTo( 0, 5 );
path.lineTo( -3, 5 );
path.lineTo( 0, 0 );
path.lineTo( 3, 5 );
path.lineTo( 0, 5 );

QTransform transform;
transform.rotate( -30.0 );
path = transform.map( path );

symbol->setPath( path );
symbol->setPinPoint( QPointF( 0.0, 0.0 ) );

setSize( 10, 14 );
.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIpath\fP Painter path
.RE
.PP
\fBNote:\fP
.RS 4
The style is implicitely set to \fBQwtSymbol::Path\fP\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpath()\fP, \fBsetSize()\fP 
.RE
.PP

.SS "void QwtSymbol::setPen (const QColor &color, qrealwidth = \fC0\&.0\fP, Qt::PenStylestyle = \fCQt::SolidLine\fP)"
Build and assign a pen
.PP
In Qt5 the default pen width is 1\&.0 ( 0\&.0 in Qt4 ) what makes it non cosmetic ( see QPen::isCosmetic() )\&. This method has been introduced to hide this incompatibility\&.
.PP
\fBParameters:\fP
.RS 4
\fIcolor\fP Pen color 
.br
\fIwidth\fP Pen width 
.br
\fIstyle\fP Pen style
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpen()\fP, \fBbrush()\fP 
.RE
.PP

.SS "void QwtSymbol::setPen (const QPen &pen)"
Assign a pen
.PP
The pen is used to draw the symbol's outline\&.
.PP
\fBParameters:\fP
.RS 4
\fIpen\fP Pen 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpen()\fP, \fBsetBrush()\fP 
.RE
.PP

.SS "void QwtSymbol::setPinPoint (const QPointF &pos, boolenable = \fCtrue\fP)"

.PP
Set and enable a pin point\&. The position of a complex symbol is not always aligned to its center ( f\&.e an arrow, where the peak points to a position )\&. The pin point defines the position inside of a Pixmap, Graphic, SvgDocument or PainterPath symbol where the represented point has to be aligned to\&.
.PP
\fBParameters:\fP
.RS 4
\fIpos\fP Position 
.br
\fIenable\fP En/Disable the pin point alignment
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpinPoint()\fP, \fBsetPinPointEnabled()\fP 
.RE
.PP

.SS "void QwtSymbol::setPinPointEnabled (boolon)"
En/Disable the pin point alignment
.PP
\fBParameters:\fP
.RS 4
\fIon\fP Enabled, when on is true 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetPinPoint()\fP, \fBisPinPointEnabled()\fP 
.RE
.PP

.SS "void QwtSymbol::setPixmap (const QPixmap &pixmap)"
Set a pixmap as symbol
.PP
\fBParameters:\fP
.RS 4
\fIpixmap\fP Pixmap
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBpixmap()\fP, \fBsetGraphic()\fP
.RE
.PP
\fBNote:\fP
.RS 4
the \fBstyle()\fP is set to \fBQwtSymbol::Pixmap\fP 
.PP
\fBbrush()\fP and \fBpen()\fP have no effect 
.RE
.PP

.SS "void QwtSymbol::setSize (const QSize &size)"
Set the symbol's size 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP Size
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsize()\fP 
.RE
.PP

.SS "void QwtSymbol::setSize (intwidth, intheight = \fC-1\fP)"

.PP
Specify the symbol's size\&. If the 'h' parameter is left out or less than 0, and the 'w' parameter is greater than or equal to 0, the symbol size will be set to (w,w)\&.
.PP
\fBParameters:\fP
.RS 4
\fIwidth\fP Width 
.br
\fIheight\fP Height (defaults to -1)
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsize()\fP 
.RE
.PP

.SS "void QwtSymbol::setStyle (\fBQwtSymbol::Style\fPstyle)"
Specify the symbol style
.PP
\fBParameters:\fP
.RS 4
\fIstyle\fP Style 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBstyle()\fP 
.RE
.PP

.SS "void QwtSymbol::setSvgDocument (const QByteArray &svgDocument)"
Set a SVG icon as symbol
.PP
\fBParameters:\fP
.RS 4
\fIsvgDocument\fP SVG icon
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetGraphic()\fP, \fBsetPixmap()\fP
.RE
.PP
\fBNote:\fP
.RS 4
the \fBstyle()\fP is set to \fBQwtSymbol::SvgDocument\fP 
.PP
\fBbrush()\fP and \fBpen()\fP have no effect 
.RE
.PP

.SS "const QSize & QwtSymbol::size () const"
\fBReturns:\fP
.RS 4
Size 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetSize()\fP 
.RE
.PP

.SS "\fBQwtSymbol::Style\fP QwtSymbol::style () const"
\fBReturns:\fP
.RS 4
Current symbol style 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBsetStyle()\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Qwt User's Guide from the source code\&.
